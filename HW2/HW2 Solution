(* Reminder: If a test case requires multiple arguments, use a tuple:
let myfn_with_2_args_tests = [
  ((arg1, arg1), (expected_output))
]
*)

(* Q1 *)
(* TODO: Write a good set of tests for compress *)
let compress_tests = [
  (([]), ([]));
  (([A]), ([(1, A)]));
  (([A;A]), ([(2, A)]));
  (([A;T]), ([(1, A); (1, T)]));
  (([A;A;G;T;T;C]), ([(2, A); (1, G); (2, T); (1, C)]));
  (([A;A;A;A;G;G;A;T;T;T;C;C]), ([(4, A); (2, G); (1, A); (3, T); (2, C)]));
]

(* TODO: Implement compress. *)
let compress (l : nucleobase list) : (int * nucleobase) list =
  let rec compress' l (r: (int*nucleobase) list) acc=
    match l with
    | [] -> []
    | [h] -> r @ [(acc, h)]
    | (h1::h2::t) ->
        if (h1 = h2) then compress' (h2::t) r (acc+1)
        else compress' (h2::t) (r @ [(acc,h1)]) 1
  in
  compress' l [] 1

(* TODO: Write a good set of tests for decompress *)
let decompress_tests = [
  (([]), ([]));
  (([1, A]), ([A]));
  (([2,C]), ([C;C])); 
  (([5,T]), ([T;T;T;T;T]));
  (([(1,A); (1,T)]), ([A;T]));
  (([(1, A); (1, T)]), ([A;T]));
  (([(1, A); (1, T)]), ([A;T])); 
  (([(2, G); (1, A)]), ([G;G;A]));
  (([(4, T); (2, G)]), ([T;T;T;T;G;G]));
  (([(3, A); (3, T); (1, G); (2, C)]), ([A;A;A;T;T;T;G;C;C]));
  (([(4, A); (2, G); (1, A); (3, T); (1, C); (1, T); (1, C)]),
   ([A;A;A;A;G;G;A;T;T;T;C;T;C]))
]

let rec makeSubList (r: nucleobase list) (a: int) (n: nucleobase)=
  if (a=0) then r
  else makeSubList (n::r) (a-1) n

(* TODO: Implement decompress. *)
let rec decompress (l : (int * nucleobase) list) : nucleobase list =
  match l with
  | [] -> []
  | (i, n)::t -> (makeSubList [] i n) @ (decompress t)
      


(* Q2 *)
(* TODO: Write a good set of tests for eval *) 
let eval_tests = [ 
  ((FLOAT 0.), (0.)); 
  ((FLOAT 342.768), (342.768));
  ((SIN (FLOAT 0.)), (0.));
  ((SIN (FLOAT 0.79)), (0.7103532724)); 
  ((COS (FLOAT 0.)), (1.));
  ((COS (FLOAT 1.25)), (0.3153223624)); 
  ((EXP (FLOAT 0.)), (1.));
  ((EXP (FLOAT 0.6)), (1.8221188)); 
  ((PLUS (FLOAT 3.4, FLOAT 0.)), (3.4));
  ((PLUS (FLOAT 0., FLOAT 5.6)), (5.6));
  ((PLUS (FLOAT 15.4, FLOAT 32.5)), (47.9));
  ((MINUS (FLOAT 3.4, FLOAT 0.)), (3.4));
  ((MINUS (FLOAT 0., FLOAT 5.6)), (-5.6));
  ((MINUS (FLOAT 15.4, FLOAT 32.5)), (-17.1));
  ((MULT (FLOAT 3.4, FLOAT 0.)), (0.));
  ((MULT (FLOAT 0., FLOAT 5.6)), (0.));
  ((MULT (FLOAT 15.4, FLOAT 32.5)), (500.5));
  ((DIV (FLOAT 0., FLOAT 3.4)), (0.));
  ((DIV (FLOAT 5., FLOAT 2.)), (2.5));
  ((DIV (FLOAT 15.4, FLOAT 32.5)), (0.4738461538));
  ((SIN(EXP(FLOAT 5.0))), (-0.6876914117));
  ((COS(MINUS(FLOAT 5.6, EXP(FLOAT 3.4)))), (0.7188559281));
  ((MULT (PLUS (FLOAT 2.2, FLOAT 3.3), FLOAT 5.0)), (27.5));
  ((DIV(FLOAT 34.5, (MINUS(FLOAT 15.4, (MULT (FLOAT 3.4, FLOAT 5.6)))))), 
   (-9.478021978))
] 

(* TODO: Implement eval. *)
let rec eval e = match e with 
  | FLOAT x -> x
  | SIN x -> sin(eval x)
  | COS x -> cos(eval x)
  | EXP x -> exp(eval x)
  | PLUS (x,y)-> ((eval x) +. (eval y))
  | MINUS (x,y) -> ((eval x) -. (eval y))
  | MULT (x,y) -> ((eval x) *. (eval y))
  | DIV (x,y) -> ((eval x) /. (eval y))
      

(* TODO: Write a good set of tests for to_instr *)
let to_instr_tests = [
  ((FLOAT 0.), ([Float 0.])); 
  ((FLOAT 342.768), ([Float 342.768]));
  ((SIN (FLOAT 0.)), ([Float 0.; Sin]));
  ((SIN (FLOAT 0.79)), ([Float 0.79; Sin])); 
  ((COS (FLOAT 0.)), ([Float 0.; Cos]));
  ((COS (FLOAT 1.25)), ([Float 1.25; Cos])); 
  ((EXP (FLOAT 0.)), ([Float 0.; Exp]));
  ((EXP (FLOAT 0.6)), ([Float 0.6; Exp])); 
  ((PLUS (FLOAT 3.4, FLOAT 0.)), ([Float 3.4; Float 0.; Plus]));
  ((PLUS (FLOAT 0., FLOAT 5.6)), ([Float 0.; Float 5.6; Plus]));
  ((PLUS (FLOAT 15.4, FLOAT 32.5)), ([Float 15.4; Float 32.5; Plus]));
  ((MINUS (FLOAT 3.4, FLOAT 0.)), ([Float 3.4; Float 0.; Minus]));
  ((MINUS (FLOAT 0., FLOAT 5.6)), ([Float 0.; Float 5.6; Minus]));
  ((MINUS (FLOAT 15.4, FLOAT 32.5)), ([Float 15.4; Float 32.5; Minus]));
  ((MULT (FLOAT 3.4, FLOAT 0.)), ([Float 3.4; Float 0.; Mult]));
  ((MULT (FLOAT 0., FLOAT 5.6)), ([Float 0.; Float 5.6; Mult]));
  ((MULT (FLOAT 15.4, FLOAT 32.5)), ([Float 15.4; Float 32.5; Mult]));
  ((DIV (FLOAT 0., FLOAT 3.4)), ([Float 0.; Float 3.4; Div]));
  ((DIV (FLOAT 5., FLOAT 2.)), ([Float 5.; Float 2.; Div]));
  ((DIV (FLOAT 15.4, FLOAT 32.5)), ([Float 15.4; Float 32.5; Div]));
  ((SIN(EXP(FLOAT 5.0))), ([Float 5.0; Exp; Sin]));
  ((COS(MINUS(FLOAT 5.6, EXP(FLOAT 3.4)))), 
   ([Float 5.6; Float 3.4; Exp; Minus; Cos]));
  ((MULT (PLUS (FLOAT 2.2, FLOAT 3.3), FLOAT 5.0)), 
   ([Float 2.2; Float 3.3; Plus; Float 5.0; Mult]));
  ((DIV(FLOAT 34.5, (MINUS(FLOAT 15.4, (MULT (FLOAT 3.4, FLOAT 5.6)))))), 
   ([Float 34.5; Float 15.4; Float 3.4; Float 5.6; Mult; Minus; Div]))
]

(* TODO: Implement to_instr. *)
let rec to_instr e = match e with
  | FLOAT x -> [Float x] 
  | SIN x -> (to_instr x) @ [Sin]
  | COS x -> (to_instr x) @ [Cos]
  | EXP x -> (to_instr x) @ [Exp]
  | PLUS (x,y) -> (to_instr x) @ (to_instr y) @ [Plus]
  | MINUS (x,y) -> (to_instr x) @ (to_instr y) @ [Minus]
  | MULT (x,y) -> (to_instr x) @ (to_instr y) @ [Mult]
  | DIV (x,y) -> (to_instr x) @ (to_instr y) @ [Div]


(* TODO: Write a good set of tests for instr *)
let instr_tests = [
]


(* TODO: Implement to_instr. *)               
let instr i s = 
  raise NotImplemented


(* TODO: Write a good set of tests for prog *)
let prog_tests = [
]

(* TODO: Implement prog. *)
let prog instrs = 
  raise NotImplemented 